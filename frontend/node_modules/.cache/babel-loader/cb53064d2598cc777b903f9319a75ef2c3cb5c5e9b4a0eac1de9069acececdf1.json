{"ast":null,"code":"import _objectSpread from \"C:/Users/krishan kant/Desktop/Js/game/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"C:/Users/krishan kant/Desktop/Js/game/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nimport { parse } from './pgn';\nconst MASK64 = 0xffffffffffffffffn;\nfunction rotl(x, k) {\n  return (x << k | x >> 64n - k) & 0xffffffffffffffffn;\n}\nfunction wrappingMul(x, y) {\n  return x * y & MASK64;\n}\n// xoroshiro128**\nexport function xoroshiro128(state) {\n  return function () {\n    let s0 = BigInt(state & MASK64);\n    let s1 = BigInt(state >> 64n & MASK64);\n    const result = wrappingMul(rotl(wrappingMul(s0, 5n), 7n), 9n);\n    s1 ^= s0;\n    s0 = (rotl(s0, 24n) ^ s1 ^ s1 << 16n) & MASK64;\n    s1 = rotl(s1, 37n);\n    state = s1 << 64n | s0;\n    return result;\n  };\n}\nconst rand = xoroshiro128(0xa187eb39cdcaed8f31c4b365b102e01en);\nconst PIECE_KEYS = Array.from({\n  length: 2\n}, () => Array.from({\n  length: 6\n}, () => Array.from({\n  length: 128\n}, () => rand())));\nconst EP_KEYS = Array.from({\n  length: 8\n}, () => rand());\nconst CASTLING_KEYS = Array.from({\n  length: 16\n}, () => rand());\nconst SIDE_KEY = rand();\nexport const WHITE = 'w';\nexport const BLACK = 'b';\nexport const PAWN = 'p';\nexport const KNIGHT = 'n';\nexport const BISHOP = 'b';\nexport const ROOK = 'r';\nexport const QUEEN = 'q';\nexport const KING = 'k';\nexport const DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nexport class Move {\n  constructor(chess, internal) {\n    _defineProperty(this, \"color\", void 0);\n    _defineProperty(this, \"from\", void 0);\n    _defineProperty(this, \"to\", void 0);\n    _defineProperty(this, \"piece\", void 0);\n    _defineProperty(this, \"captured\", void 0);\n    _defineProperty(this, \"promotion\", void 0);\n    /**\n     * @deprecated This field is deprecated and will be removed in version 2.0.0.\n     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n     * `isBigPawn`\n     */\n    _defineProperty(this, \"flags\", void 0);\n    _defineProperty(this, \"san\", void 0);\n    _defineProperty(this, \"lan\", void 0);\n    _defineProperty(this, \"before\", void 0);\n    _defineProperty(this, \"after\", void 0);\n    const {\n      color,\n      piece,\n      from,\n      to,\n      flags,\n      captured,\n      promotion\n    } = internal;\n    const fromAlgebraic = algebraic(from);\n    const toAlgebraic = algebraic(to);\n    this.color = color;\n    this.piece = piece;\n    this.from = fromAlgebraic;\n    this.to = toAlgebraic;\n    /*\n     * HACK: The chess['_method']() calls below invoke private methods in the\n     * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n     * code cleaner elsewhere.\n     */\n    this.san = chess['_moveToSan'](internal, chess['_moves']({\n      legal: true\n    }));\n    this.lan = fromAlgebraic + toAlgebraic;\n    this.before = chess.fen();\n    // Generate the FEN for the 'after' key\n    chess['_makeMove'](internal);\n    this.after = chess.fen();\n    chess['_undoMove']();\n    // Build the text representation of the move flags\n    this.flags = '';\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        this.flags += FLAGS[flag];\n      }\n    }\n    if (captured) {\n      this.captured = captured;\n    }\n    if (promotion) {\n      this.promotion = promotion;\n      this.lan += promotion;\n    }\n  }\n  isCapture() {\n    return this.flags.indexOf(FLAGS['CAPTURE']) > -1;\n  }\n  isPromotion() {\n    return this.flags.indexOf(FLAGS['PROMOTION']) > -1;\n  }\n  isEnPassant() {\n    return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1;\n  }\n  isKingsideCastle() {\n    return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1;\n  }\n  isQueensideCastle() {\n    return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1;\n  }\n  isBigPawn() {\n    return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1;\n  }\n}\nconst EMPTY = -1;\nconst FLAGS = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q'\n};\n// prettier-ignore\nexport const SQUARES = ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8', 'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7', 'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6', 'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5', 'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4', 'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3', 'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2', 'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'];\nconst BITS = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64\n};\n/* eslint-disable @typescript-eslint/naming-convention */\n// these are required, according to spec\nexport const SEVEN_TAG_ROSTER = {\n  Event: '?',\n  Site: '?',\n  Date: '????.??.??',\n  Round: '?',\n  White: '?',\n  Black: '?',\n  Result: '*'\n};\n/**\n * These nulls are placeholders to fix the order of tags (as they appear in PGN spec); null values will be\n * eliminated in getHeaders()\n */\nconst SUPLEMENTAL_TAGS = {\n  WhiteTitle: null,\n  BlackTitle: null,\n  WhiteElo: null,\n  BlackElo: null,\n  WhiteUSCF: null,\n  BlackUSCF: null,\n  WhiteNA: null,\n  BlackNA: null,\n  WhiteType: null,\n  BlackType: null,\n  EventDate: null,\n  EventSponsor: null,\n  Section: null,\n  Stage: null,\n  Board: null,\n  Opening: null,\n  Variation: null,\n  SubVariation: null,\n  ECO: null,\n  NIC: null,\n  Time: null,\n  UTCTime: null,\n  UTCDate: null,\n  TimeControl: null,\n  SetUp: null,\n  FEN: null,\n  Termination: null,\n  Annotator: null,\n  Mode: null,\n  PlyCount: null\n};\nconst HEADER_TEMPLATE = _objectSpread(_objectSpread({}, SEVEN_TAG_ROSTER), SUPLEMENTAL_TAGS);\n/* eslint-enable @typescript-eslint/naming-convention */\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n  a8: 0,\n  b8: 1,\n  c8: 2,\n  d8: 3,\n  e8: 4,\n  f8: 5,\n  g8: 6,\n  h8: 7,\n  a7: 16,\n  b7: 17,\n  c7: 18,\n  d7: 19,\n  e7: 20,\n  f7: 21,\n  g7: 22,\n  h7: 23,\n  a6: 32,\n  b6: 33,\n  c6: 34,\n  d6: 35,\n  e6: 36,\n  f6: 37,\n  g6: 38,\n  h6: 39,\n  a5: 48,\n  b5: 49,\n  c5: 50,\n  d5: 51,\n  e5: 52,\n  f5: 53,\n  g5: 54,\n  h5: 55,\n  a4: 64,\n  b4: 65,\n  c4: 66,\n  d4: 67,\n  e4: 68,\n  f4: 69,\n  g4: 70,\n  h4: 71,\n  a3: 80,\n  b3: 81,\n  c3: 82,\n  d3: 83,\n  e3: 84,\n  f3: 85,\n  g3: 86,\n  h3: 87,\n  a2: 96,\n  b2: 97,\n  c2: 98,\n  d2: 99,\n  e2: 100,\n  f2: 101,\n  g2: 102,\n  h2: 103,\n  a1: 112,\n  b1: 113,\n  c1: 114,\n  d1: 115,\n  e1: 116,\n  f1: 117,\n  g1: 118,\n  h1: 119\n};\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15]\n};\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1]\n};\n// prettier-ignore\nconst ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20];\n// prettier-ignore\nconst RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\nconst PIECE_MASKS = {\n  p: 0x1,\n  n: 0x2,\n  b: 0x4,\n  r: 0x8,\n  q: 0x10,\n  k: 0x20\n};\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n  [KING]: BITS.KSIDE_CASTLE,\n  [QUEEN]: BITS.QSIDE_CASTLE\n};\nconst ROOKS = {\n  w: [{\n    square: Ox88.a1,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h1,\n    flag: BITS.KSIDE_CASTLE\n  }],\n  b: [{\n    square: Ox88.a8,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h8,\n    flag: BITS.KSIDE_CASTLE\n  }]\n};\nconst SECOND_RANK = {\n  b: RANK_7,\n  w: RANK_2\n};\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n  return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n  return square & 0xf;\n}\nfunction isDigit(c) {\n  return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n  const f = file(square);\n  const r = rank(square);\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n}\nfunction swapColor(color) {\n  return color === WHITE ? BLACK : WHITE;\n}\nexport function validateFen(fen) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/);\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields'\n    };\n  }\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10);\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer'\n    };\n  }\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10);\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: half move counter number must be a non-negative integer'\n    };\n  }\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: en-passant square is invalid'\n    };\n  }\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: castling availability is invalid'\n    };\n  }\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: side-to-move is invalid'\n    };\n  }\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/');\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n    };\n  }\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0;\n    let previousWasNumber = false;\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)'\n          };\n        }\n        sumFields += parseInt(rows[i][k], 10);\n        previousWasNumber = true;\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)'\n          };\n        }\n        sumFields += 1;\n        previousWasNumber = false;\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)'\n      };\n    }\n  }\n  // 9th criterion: is en-passant square legal?\n  if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n    return {\n      ok: false,\n      error: 'Invalid FEN: illegal en-passant square'\n    };\n  }\n  // 10th criterion: does chess position contain exact two kings?\n  const kings = [{\n    color: 'white',\n    regex: /K/g\n  }, {\n    color: 'black',\n    regex: /k/g\n  }];\n  for (const {\n    color,\n    regex\n  } of kings) {\n    if (!regex.test(tokens[0])) {\n      return {\n        ok: false,\n        error: \"Invalid FEN: missing \".concat(color, \" king\")\n      };\n    }\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return {\n        ok: false,\n        error: \"Invalid FEN: too many \".concat(color, \" kings\")\n      };\n    }\n  }\n  // 11th criterion: are any pawns on the first or eighth rows?\n  if (Array.from(rows[0] + rows[7]).some(char => char.toUpperCase() === 'P')) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: some pawns are on the edge rows'\n    };\n  }\n  return {\n    ok: true\n  };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n  const from = move.from;\n  const to = move.to;\n  const piece = move.piece;\n  let ambiguities = 0;\n  let sameRank = 0;\n  let sameFile = 0;\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from;\n    const ambigTo = moves[i].to;\n    const ambigPiece = moves[i].piece;\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++;\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++;\n      }\n      if (file(from) === file(ambigFrom)) {\n        sameFile++;\n      }\n    }\n  }\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from);\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1);\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0);\n    }\n  }\n  return '';\n}\nfunction addMove(moves, color, from, to, piece) {\n  let captured = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n  let flags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : BITS.NORMAL;\n  const r = rank(to);\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i];\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION\n      });\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags\n    });\n  }\n}\nfunction inferPieceType(san) {\n  let pieceType = san.charAt(0);\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n    if (matches) {\n      return undefined;\n    }\n    return PAWN;\n  }\n  pieceType = pieceType.toLowerCase();\n  if (pieceType === 'o') {\n    return KING;\n  }\n  return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nexport class Chess {\n  constructor() {\n    let fen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_POSITION;\n    let {\n      skipValidation = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _defineProperty(this, \"_board\", new Array(128));\n    _defineProperty(this, \"_turn\", WHITE);\n    _defineProperty(this, \"_header\", {});\n    _defineProperty(this, \"_kings\", {\n      w: EMPTY,\n      b: EMPTY\n    });\n    _defineProperty(this, \"_epSquare\", -1);\n    _defineProperty(this, \"_halfMoves\", 0);\n    _defineProperty(this, \"_moveNumber\", 0);\n    _defineProperty(this, \"_history\", []);\n    _defineProperty(this, \"_comments\", {});\n    _defineProperty(this, \"_castling\", {\n      w: 0,\n      b: 0\n    });\n    _defineProperty(this, \"_hash\", 0n);\n    // tracks number of times a position has been seen for repetition checking\n    _defineProperty(this, \"_positionCount\", new Map());\n    this.load(fen, {\n      skipValidation\n    });\n  }\n  clear() {\n    let {\n      preserveHeaders = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._board = new Array(128);\n    this._kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    this._turn = WHITE;\n    this._castling = {\n      w: 0,\n      b: 0\n    };\n    this._epSquare = EMPTY;\n    this._halfMoves = 0;\n    this._moveNumber = 1;\n    this._history = [];\n    this._comments = {};\n    this._header = preserveHeaders ? this._header : _objectSpread({}, HEADER_TEMPLATE);\n    this._hash = this._computeHash();\n    this._positionCount = new Map();\n    /*\n     * Delete the SetUp and FEN headers (if preserved), the board is empty and\n     * these headers don't make sense in this state. They'll get added later\n     * via .load() or .put()\n     */\n    this._header['SetUp'] = null;\n    this._header['FEN'] = null;\n  }\n  load(fen) {\n    let {\n      skipValidation = false,\n      preserveHeaders = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tokens = fen.split(/\\s+/);\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1'];\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n    }\n    tokens = fen.split(/\\s+/);\n    if (!skipValidation) {\n      const {\n        ok,\n        error\n      } = validateFen(fen);\n      if (!ok) {\n        throw new Error(error);\n      }\n    }\n    const position = tokens[0];\n    let square = 0;\n    this.clear({\n      preserveHeaders\n    });\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i);\n      if (piece === '/') {\n        square += 8;\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        const color = piece < 'a' ? WHITE : BLACK;\n        this._put({\n          type: piece.toLowerCase(),\n          color\n        }, algebraic(square));\n        square++;\n      }\n    }\n    this._turn = tokens[1];\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE;\n    }\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n    this._halfMoves = parseInt(tokens[4], 10);\n    this._moveNumber = parseInt(tokens[5], 10);\n    this._hash = this._computeHash();\n    this._updateSetup(fen);\n    this._incPositionCount();\n  }\n  fen() {\n    let {\n      forceEnpassantSquare = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let empty = 0;\n    let fen = '';\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        const {\n          color,\n          type: piece\n        } = this._board[i];\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      } else {\n        empty++;\n      }\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n        if (i !== Ox88.h1) {\n          fen += '/';\n        }\n        empty = 0;\n        i += 8;\n      }\n    }\n    let castling = '';\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K';\n    }\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q';\n    }\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k';\n    }\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q';\n    }\n    // do we have an empty castling flag?\n    castling = castling || '-';\n    let epSquare = '-';\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n    if (this._epSquare !== EMPTY) {\n      if (forceEnpassantSquare) {\n        epSquare = algebraic(this._epSquare);\n      } else {\n        const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n        for (const square of squares) {\n          var _this$_board$square, _this$_board$square2;\n          // is the square off the board?\n          if (square & 0x88) {\n            continue;\n          }\n          const color = this._turn;\n          // is there a pawn that can capture the epSquare?\n          if (((_this$_board$square = this._board[square]) === null || _this$_board$square === void 0 ? void 0 : _this$_board$square.color) === color && ((_this$_board$square2 = this._board[square]) === null || _this$_board$square2 === void 0 ? void 0 : _this$_board$square2.type) === PAWN) {\n            // if the pawn makes an ep capture, does it leave its king in check?\n            this._makeMove({\n              color,\n              from: square,\n              to: this._epSquare,\n              piece: PAWN,\n              captured: PAWN,\n              flags: BITS.EP_CAPTURE\n            });\n            const isLegal = !this._isKingAttacked(color);\n            this._undoMove();\n            // if ep is legal, break and set the ep square in the FEN output\n            if (isLegal) {\n              epSquare = algebraic(this._epSquare);\n              break;\n            }\n          }\n        }\n      }\n    }\n    return [fen, this._turn, castling, epSquare, this._halfMoves, this._moveNumber].join(' ');\n  }\n  _pieceKey(i) {\n    if (!this._board[i]) {\n      return 0n;\n    }\n    const {\n      color,\n      type\n    } = this._board[i];\n    const colorIndex = {\n      w: 0,\n      b: 1\n    }[color];\n    const typeIndex = {\n      p: 0,\n      n: 1,\n      b: 2,\n      r: 3,\n      q: 4,\n      k: 5\n    }[type];\n    return PIECE_KEYS[colorIndex][typeIndex][i];\n  }\n  _epKey() {\n    return this._epSquare === EMPTY ? 0n : EP_KEYS[this._epSquare & 7];\n  }\n  _castlingKey() {\n    const index = this._castling.w >> 5 | this._castling.b >> 3;\n    return CASTLING_KEYS[index];\n  }\n  _computeHash() {\n    let hash = 0n;\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      if (this._board[i]) {\n        hash ^= this._pieceKey(i);\n      }\n    }\n    hash ^= this._epKey();\n    hash ^= this._castlingKey();\n    if (this._turn === 'b') {\n      hash ^= SIDE_KEY;\n    }\n    return hash;\n  }\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n  _updateSetup(fen) {\n    if (this._history.length > 0) return;\n    if (fen !== DEFAULT_POSITION) {\n      this._header['SetUp'] = '1';\n      this._header['FEN'] = fen;\n    } else {\n      this._header['SetUp'] = null;\n      this._header['FEN'] = null;\n    }\n  }\n  reset() {\n    this.load(DEFAULT_POSITION);\n  }\n  get(square) {\n    return this._board[Ox88[square]];\n  }\n  findPiece(piece) {\n    const squares = [];\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      var _this$_board$i;\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      // if empty square or wrong color\n      if (!this._board[i] || ((_this$_board$i = this._board[i]) === null || _this$_board$i === void 0 ? void 0 : _this$_board$i.color) !== piece.color) {\n        continue;\n      }\n      // check if square contains the requested piece\n      if (this._board[i].color === piece.color && this._board[i].type === piece.type) {\n        squares.push(algebraic(i));\n      }\n    }\n    return squares;\n  }\n  put(_ref, square) {\n    let {\n      type,\n      color\n    } = _ref;\n    if (this._put({\n      type,\n      color\n    }, square)) {\n      this._updateCastlingRights();\n      this._updateEnPassantSquare();\n      this._updateSetup(this.fen());\n      return true;\n    }\n    return false;\n  }\n  _set(sq, piece) {\n    this._hash ^= this._pieceKey(sq);\n    this._board[sq] = piece;\n    this._hash ^= this._pieceKey(sq);\n  }\n  _put(_ref2, square) {\n    let {\n      type,\n      color\n    } = _ref2;\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false;\n    }\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false;\n    }\n    const sq = Ox88[square];\n    // don't let the user place more than one king\n    if (type == KING && !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n      return false;\n    }\n    const currentPieceOnSquare = this._board[sq];\n    // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n    if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n      this._kings[currentPieceOnSquare.color] = EMPTY;\n    }\n    this._set(sq, {\n      type: type,\n      color: color\n    });\n    if (type === KING) {\n      this._kings[color] = sq;\n    }\n    return true;\n  }\n  _clear(sq) {\n    this._hash ^= this._pieceKey(sq);\n    delete this._board[sq];\n  }\n  remove(square) {\n    const piece = this.get(square);\n    this._clear(Ox88[square]);\n    if (piece && piece.type === KING) {\n      this._kings[piece.color] = EMPTY;\n    }\n    this._updateCastlingRights();\n    this._updateEnPassantSquare();\n    this._updateSetup(this.fen());\n    return piece;\n  }\n  _updateCastlingRights() {\n    var _this$_board$Ox88$e, _this$_board$Ox88$e2, _this$_board$Ox88$e3, _this$_board$Ox88$e4, _this$_board$Ox88$a, _this$_board$Ox88$a2, _this$_board$Ox88$h, _this$_board$Ox88$h2, _this$_board$Ox88$a3, _this$_board$Ox88$a4, _this$_board$Ox88$h3, _this$_board$Ox88$h4;\n    this._hash ^= this._castlingKey();\n    const whiteKingInPlace = ((_this$_board$Ox88$e = this._board[Ox88.e1]) === null || _this$_board$Ox88$e === void 0 ? void 0 : _this$_board$Ox88$e.type) === KING && ((_this$_board$Ox88$e2 = this._board[Ox88.e1]) === null || _this$_board$Ox88$e2 === void 0 ? void 0 : _this$_board$Ox88$e2.color) === WHITE;\n    const blackKingInPlace = ((_this$_board$Ox88$e3 = this._board[Ox88.e8]) === null || _this$_board$Ox88$e3 === void 0 ? void 0 : _this$_board$Ox88$e3.type) === KING && ((_this$_board$Ox88$e4 = this._board[Ox88.e8]) === null || _this$_board$Ox88$e4 === void 0 ? void 0 : _this$_board$Ox88$e4.color) === BLACK;\n    if (!whiteKingInPlace || ((_this$_board$Ox88$a = this._board[Ox88.a1]) === null || _this$_board$Ox88$a === void 0 ? void 0 : _this$_board$Ox88$a.type) !== ROOK || ((_this$_board$Ox88$a2 = this._board[Ox88.a1]) === null || _this$_board$Ox88$a2 === void 0 ? void 0 : _this$_board$Ox88$a2.color) !== WHITE) {\n      this._castling.w &= ~BITS.QSIDE_CASTLE;\n    }\n    if (!whiteKingInPlace || ((_this$_board$Ox88$h = this._board[Ox88.h1]) === null || _this$_board$Ox88$h === void 0 ? void 0 : _this$_board$Ox88$h.type) !== ROOK || ((_this$_board$Ox88$h2 = this._board[Ox88.h1]) === null || _this$_board$Ox88$h2 === void 0 ? void 0 : _this$_board$Ox88$h2.color) !== WHITE) {\n      this._castling.w &= ~BITS.KSIDE_CASTLE;\n    }\n    if (!blackKingInPlace || ((_this$_board$Ox88$a3 = this._board[Ox88.a8]) === null || _this$_board$Ox88$a3 === void 0 ? void 0 : _this$_board$Ox88$a3.type) !== ROOK || ((_this$_board$Ox88$a4 = this._board[Ox88.a8]) === null || _this$_board$Ox88$a4 === void 0 ? void 0 : _this$_board$Ox88$a4.color) !== BLACK) {\n      this._castling.b &= ~BITS.QSIDE_CASTLE;\n    }\n    if (!blackKingInPlace || ((_this$_board$Ox88$h3 = this._board[Ox88.h8]) === null || _this$_board$Ox88$h3 === void 0 ? void 0 : _this$_board$Ox88$h3.type) !== ROOK || ((_this$_board$Ox88$h4 = this._board[Ox88.h8]) === null || _this$_board$Ox88$h4 === void 0 ? void 0 : _this$_board$Ox88$h4.color) !== BLACK) {\n      this._castling.b &= ~BITS.KSIDE_CASTLE;\n    }\n    this._hash ^= this._castlingKey();\n  }\n  _updateEnPassantSquare() {\n    var _this$_board$currentS, _this$_board$currentS2;\n    if (this._epSquare === EMPTY) {\n      return;\n    }\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n    const attackers = [currentSquare + 1, currentSquare - 1];\n    if (this._board[startSquare] !== null || this._board[this._epSquare] !== null || ((_this$_board$currentS = this._board[currentSquare]) === null || _this$_board$currentS === void 0 ? void 0 : _this$_board$currentS.color) !== swapColor(this._turn) || ((_this$_board$currentS2 = this._board[currentSquare]) === null || _this$_board$currentS2 === void 0 ? void 0 : _this$_board$currentS2.type) !== PAWN) {\n      this._hash ^= this._epKey();\n      this._epSquare = EMPTY;\n      return;\n    }\n    const canCapture = square => {\n      var _this$_board$square3, _this$_board$square4;\n      return !(square & 0x88) && ((_this$_board$square3 = this._board[square]) === null || _this$_board$square3 === void 0 ? void 0 : _this$_board$square3.color) === this._turn && ((_this$_board$square4 = this._board[square]) === null || _this$_board$square4 === void 0 ? void 0 : _this$_board$square4.type) === PAWN;\n    };\n    if (!attackers.some(canCapture)) {\n      this._hash ^= this._epKey();\n      this._epSquare = EMPTY;\n    }\n  }\n  _attacked(color, square, verbose) {\n    const attackers = [];\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue;\n      }\n      const piece = this._board[i];\n      const difference = i - square;\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue;\n      }\n      const index = difference + 119;\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0 && piece.color === WHITE || difference <= 0 && piece.color === BLACK) {\n            if (!verbose) {\n              return true;\n            } else {\n              attackers.push(algebraic(i));\n            }\n          }\n          continue;\n        }\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') {\n          if (!verbose) {\n            return true;\n          } else {\n            attackers.push(algebraic(i));\n            continue;\n          }\n        }\n        const offset = RAYS[index];\n        let j = i + offset;\n        let blocked = false;\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true;\n            break;\n          }\n          j += offset;\n        }\n        if (!blocked) {\n          if (!verbose) {\n            return true;\n          } else {\n            attackers.push(algebraic(i));\n            continue;\n          }\n        }\n      }\n    }\n    if (verbose) {\n      return attackers;\n    } else {\n      return false;\n    }\n  }\n  attackers(square, attackedBy) {\n    if (!attackedBy) {\n      return this._attacked(this._turn, Ox88[square], true);\n    } else {\n      return this._attacked(attackedBy, Ox88[square], true);\n    }\n  }\n  _isKingAttacked(color) {\n    const square = this._kings[color];\n    return square === -1 ? false : this._attacked(swapColor(color), square);\n  }\n  hash() {\n    return this._hash.toString(16);\n  }\n  isAttacked(square, attackedBy) {\n    return this._attacked(attackedBy, Ox88[square]);\n  }\n  isCheck() {\n    return this._isKingAttacked(this._turn);\n  }\n  inCheck() {\n    return this.isCheck();\n  }\n  isCheckmate() {\n    return this.isCheck() && this._moves().length === 0;\n  }\n  isStalemate() {\n    return !this.isCheck() && this._moves().length === 0;\n  }\n  isInsufficientMaterial() {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0\n    };\n    const bishops = [];\n    let numPieces = 0;\n    let squareColor = 0;\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2;\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      const piece = this._board[i];\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n        if (piece.type === BISHOP) {\n          bishops.push(squareColor);\n        }\n        numPieces++;\n      }\n    }\n    // k vs. k\n    if (numPieces === 2) {\n      return true;\n    } else if (\n    // k vs. kn .... or .... k vs. kb\n    numPieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n      return true;\n    } else if (numPieces === pieces[BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0;\n      const len = bishops.length;\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n      if (sum === 0 || sum === len) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isThreefoldRepetition() {\n    return this._getPositionCount(this._hash) >= 3;\n  }\n  isDrawByFiftyMoves() {\n    return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n  }\n  isDraw() {\n    return this.isDrawByFiftyMoves() || this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n  }\n  isGameOver() {\n    return this.isCheckmate() || this.isDraw();\n  }\n  moves() {\n    let {\n      verbose = false,\n      square = undefined,\n      piece = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const moves = this._moves({\n      square,\n      piece\n    });\n    if (verbose) {\n      return moves.map(move => new Move(this, move));\n    } else {\n      return moves.map(move => this._moveToSan(move, moves));\n    }\n  }\n  _moves() {\n    let {\n      legal = true,\n      piece = undefined,\n      square = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const forSquare = square ? square.toLowerCase() : undefined;\n    const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n    const moves = [];\n    const us = this._turn;\n    const them = swapColor(us);\n    let firstSquare = Ox88.a8;\n    let lastSquare = Ox88.h1;\n    let singleSquare = false;\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return [];\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare];\n        singleSquare = true;\n      }\n    }\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7;\n        continue;\n      }\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue;\n      }\n      const {\n        type\n      } = this._board[from];\n      let to;\n      if (type === PAWN) {\n        if (forPiece && forPiece !== type) continue;\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0];\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, PAWN);\n          // double square\n          to = from + PAWN_OFFSETS[us][1];\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n          }\n        }\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          var _this$_board$to;\n          to = from + PAWN_OFFSETS[us][j];\n          if (to & 0x88) continue;\n          if (((_this$_board$to = this._board[to]) === null || _this$_board$to === void 0 ? void 0 : _this$_board$to.color) === them) {\n            addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue;\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j];\n          to = from;\n          while (true) {\n            to += offset;\n            if (to & 0x88) break;\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type);\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break;\n              addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n              break;\n            }\n            /* break, if knight or king */\n            if (type === KNIGHT || type === KING) break;\n          }\n        }\n      }\n    }\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n    if (forPiece === undefined || forPiece === KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom + 2;\n          if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n          }\n        }\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom - 2;\n          if (!this._board[castlingFrom - 1] && !this._board[castlingFrom - 2] && !this._board[castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom - 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n          }\n        }\n      }\n    }\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal || this._kings[us] === -1) {\n      return moves;\n    }\n    // filter out illegal moves\n    const legalMoves = [];\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i]);\n      }\n      this._undoMove();\n    }\n    return legalMoves;\n  }\n  move(move) {\n    let {\n      strict = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n    let moveObj = null;\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict);\n    } else if (typeof move === 'object') {\n      const moves = this._moves();\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n          moveObj = moves[i];\n          break;\n        }\n      }\n    }\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(\"Invalid move: \".concat(move));\n      } else {\n        throw new Error(\"Invalid move: \".concat(JSON.stringify(move)));\n      }\n    }\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n    const prettyMove = new Move(this, moveObj);\n    this._makeMove(moveObj);\n    this._incPositionCount();\n    return prettyMove;\n  }\n  _push(move) {\n    this._history.push({\n      move,\n      kings: {\n        b: this._kings.b,\n        w: this._kings.w\n      },\n      turn: this._turn,\n      castling: {\n        b: this._castling.b,\n        w: this._castling.w\n      },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber\n    });\n  }\n  _movePiece(from, to) {\n    this._hash ^= this._pieceKey(from);\n    this._board[to] = this._board[from];\n    delete this._board[from];\n    this._hash ^= this._pieceKey(to);\n  }\n  _makeMove(move) {\n    const us = this._turn;\n    const them = swapColor(us);\n    this._push(move);\n    this._hash ^= this._epKey();\n    this._hash ^= this._castlingKey();\n    if (move.captured) {\n      this._hash ^= this._pieceKey(move.to);\n    }\n    this._movePiece(move.from, move.to);\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === BLACK) {\n        this._clear(move.to - 16);\n      } else {\n        this._clear(move.to + 16);\n      }\n    }\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._clear(move.to);\n      this._set(move.to, {\n        type: move.promotion,\n        color: us\n      });\n    }\n    // if we moved the king\n    if (this._board[move.to].type === KING) {\n      this._kings[us] = move.to;\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1;\n        const castlingFrom = move.to + 1;\n        this._movePiece(castlingFrom, castlingTo);\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1;\n        const castlingFrom = move.to - 2;\n        this._movePiece(castlingFrom, castlingTo);\n      }\n      // turn off castling\n      this._castling[us] = 0;\n    }\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && this._castling[us] & ROOKS[us][i].flag) {\n          this._castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && this._castling[them] & ROOKS[them][i].flag) {\n          this._castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n    this._hash ^= this._castlingKey();\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      var _this$_board, _this$_board2, _this$_board3, _this$_board4;\n      let epSquare;\n      if (us === BLACK) {\n        epSquare = move.to - 16;\n      } else {\n        epSquare = move.to + 16;\n      }\n      if (!(move.to - 1 & 0x88) && ((_this$_board = this._board[move.to - 1]) === null || _this$_board === void 0 ? void 0 : _this$_board.type) === PAWN && ((_this$_board2 = this._board[move.to - 1]) === null || _this$_board2 === void 0 ? void 0 : _this$_board2.color) === them || !(move.to + 1 & 0x88) && ((_this$_board3 = this._board[move.to + 1]) === null || _this$_board3 === void 0 ? void 0 : _this$_board3.type) === PAWN && ((_this$_board4 = this._board[move.to + 1]) === null || _this$_board4 === void 0 ? void 0 : _this$_board4.color) === them) {\n        this._epSquare = epSquare;\n        this._hash ^= this._epKey();\n      } else {\n        this._epSquare = EMPTY;\n      }\n    } else {\n      this._epSquare = EMPTY;\n    }\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === PAWN) {\n      this._halfMoves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0;\n    } else {\n      this._halfMoves++;\n    }\n    if (us === BLACK) {\n      this._moveNumber++;\n    }\n    this._turn = them;\n    this._hash ^= SIDE_KEY;\n  }\n  undo() {\n    const hash = this._hash;\n    const move = this._undoMove();\n    if (move) {\n      const prettyMove = new Move(this, move);\n      this._decPositionCount(hash);\n      return prettyMove;\n    }\n    return null;\n  }\n  _undoMove() {\n    const old = this._history.pop();\n    if (old === undefined) {\n      return null;\n    }\n    this._hash ^= this._epKey();\n    this._hash ^= this._castlingKey();\n    const move = old.move;\n    this._kings = old.kings;\n    this._turn = old.turn;\n    this._castling = old.castling;\n    this._epSquare = old.epSquare;\n    this._halfMoves = old.halfMoves;\n    this._moveNumber = old.moveNumber;\n    this._hash ^= this._epKey();\n    this._hash ^= this._castlingKey();\n    this._hash ^= SIDE_KEY;\n    const us = this._turn;\n    const them = swapColor(us);\n    this._movePiece(move.to, move.from);\n    // to undo any promotions\n    if (move.piece) {\n      this._clear(move.from);\n      this._set(move.from, {\n        type: move.piece,\n        color: us\n      });\n    }\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index;\n        if (us === BLACK) {\n          index = move.to - 16;\n        } else {\n          index = move.to + 16;\n        }\n        this._set(index, {\n          type: PAWN,\n          color: them\n        });\n      } else {\n        // regular capture\n        this._set(move.to, {\n          type: move.captured,\n          color: them\n        });\n      }\n    }\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo, castlingFrom;\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1;\n        castlingFrom = move.to - 1;\n      } else {\n        castlingTo = move.to - 2;\n        castlingFrom = move.to + 1;\n      }\n      this._movePiece(castlingFrom, castlingTo);\n    }\n    return move;\n  }\n  pgn() {\n    let {\n      newline = '\\n',\n      maxWidth = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n    const result = [];\n    let headerExists = false;\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       *\n       * By using HEADER_TEMPLATE, the order of tags should be preserved; we\n       * do have to check for null placeholders, though, and omit them\n       */\n      const headerTag = this._header[i];\n      if (headerTag) result.push(\"[\".concat(i, \" \\\"\").concat(this._header[i], \"\\\"]\") + newline);\n      headerExists = true;\n    }\n    if (headerExists && this._history.length) {\n      result.push(newline);\n    }\n    const appendComment = moveString => {\n      const comment = this._comments[this.fen()];\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : '';\n        moveString = \"\".concat(moveString).concat(delimiter, \"{\").concat(comment, \"}\");\n      }\n      return moveString;\n    };\n    // pop all of history onto reversed_history\n    const reversedHistory = [];\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    const moves = [];\n    let moveString = '';\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''));\n    }\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString);\n      const move = reversedHistory.pop();\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break;\n      }\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = \"\".concat(this._moveNumber, \". ...\");\n        // is there a comment preceding the first move?\n        moveString = moveString ? \"\".concat(moveString, \" \").concat(prefix) : prefix;\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString);\n        }\n        moveString = this._moveNumber + '.';\n      }\n      moveString = moveString + ' ' + this._moveToSan(move, this._moves({\n        legal: true\n      }));\n      this._makeMove(move);\n    }\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString));\n    }\n    // is there a result? (there ALWAYS has to be a result according to spec; see Seven Tag Roster)\n    moves.push(this._header.Result || '*');\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ');\n    }\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop();\n        return true;\n      }\n      return false;\n    };\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width, move) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue;\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--;\n          }\n          result.push(newline);\n          width = 0;\n        }\n        result.push(token);\n        width += token.length;\n        result.push(' ');\n        width++;\n      }\n      if (strip()) {\n        width--;\n      }\n      return width;\n    };\n    // wrap the PGN output at max_width\n    let currentWidth = 0;\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i]);\n          continue;\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop();\n        }\n        result.push(newline);\n        currentWidth = 0;\n      } else if (i !== 0) {\n        result.push(' ');\n        currentWidth++;\n      }\n      result.push(moves[i]);\n      currentWidth += moves[i].length;\n    }\n    return result.join('');\n  }\n  /**\n   * @deprecated Use `setHeader` and `getHeaders` instead. This method will return null header tags (which is not what you want)\n   */\n  header() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1];\n      }\n    }\n    return this._header;\n  }\n  // TODO: value validation per spec\n  setHeader(key, value) {\n    var _ref3;\n    this._header[key] = (_ref3 = value !== null && value !== void 0 ? value : SEVEN_TAG_ROSTER[key]) !== null && _ref3 !== void 0 ? _ref3 : null;\n    return this.getHeaders();\n  }\n  removeHeader(key) {\n    if (key in this._header) {\n      this._header[key] = SEVEN_TAG_ROSTER[key] || null;\n      return true;\n    }\n    return false;\n  }\n  // return only non-null headers (omit placemarker nulls)\n  getHeaders() {\n    const nonNullHeaders = {};\n    for (const [key, value] of Object.entries(this._header)) {\n      if (value !== null) {\n        nonNullHeaders[key] = value;\n      }\n    }\n    return nonNullHeaders;\n  }\n  loadPgn(pgn) {\n    let {\n      strict = false,\n      newlineChar = '\\r?\\n'\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // If newlineChar is not the default, replace all instances with \\n\n    if (newlineChar !== '\\r?\\n') {\n      pgn = pgn.replace(new RegExp(newlineChar, 'g'), '\\n');\n    }\n    const parsedPgn = parse(pgn);\n    // Put the board in the starting position\n    this.reset();\n    // parse PGN header\n    const headers = parsedPgn.headers;\n    let fen = '';\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key];\n      }\n      this.header(key, headers[key]);\n    }\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, {\n          preserveHeaders: true\n        });\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n        }\n        // don't clear the headers when loading\n        this.load(headers['FEN'], {\n          preserveHeaders: true\n        });\n      }\n    }\n    let node = parsedPgn.root;\n    while (node) {\n      if (node.move) {\n        const move = this._moveFromSan(node.move, strict);\n        if (move == null) {\n          throw new Error(\"Invalid move in PGN: \".concat(node.move));\n        } else {\n          this._makeMove(move);\n          this._incPositionCount();\n        }\n      }\n      if (node.comment !== undefined) {\n        this._comments[this.fen()] = node.comment;\n      }\n      node = node.variations[0];\n    }\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n    const result = parsedPgn.result;\n    if (result && Object.keys(this._header).length && this._header['Result'] !== result) {\n      this.setHeader('Result', result);\n    }\n  }\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n  _moveToSan(move, moves) {\n    let output = '';\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      if (move.piece !== PAWN) {\n        const disambiguator = getDisambiguator(move, moves);\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0];\n        }\n        output += 'x';\n      }\n      output += algebraic(move.to);\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n    this._makeMove(move);\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n    this._undoMove();\n    return output;\n  }\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  _moveFromSan(move) {\n    let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    let cleanMove = strippedSan(move);\n    if (!strict) {\n      if (cleanMove === '0-0') {\n        cleanMove = 'O-O';\n      } else if (cleanMove === '0-0-0') {\n        cleanMove = 'O-O-O';\n      }\n    }\n    let pieceType = inferPieceType(cleanMove);\n    let moves = this._moves({\n      legal: true,\n      piece: pieceType\n    });\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i];\n      }\n    }\n    // the strict parser failed\n    if (strict) {\n      return null;\n    }\n    let piece = undefined;\n    let matches = undefined;\n    let from = undefined;\n    let to = undefined;\n    let promotion = undefined;\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n    let overlyDisambiguated = false;\n    matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n    if (matches) {\n      piece = matches[1];\n      from = matches[2];\n      to = matches[3];\n      promotion = matches[4];\n      if (from.length == 1) {\n        overlyDisambiguated = true;\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n      matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n      if (matches) {\n        piece = matches[1];\n        from = matches[2];\n        to = matches[3];\n        promotion = matches[4];\n        if (from.length == 1) {\n          overlyDisambiguated = true;\n        }\n      }\n    }\n    pieceType = inferPieceType(cleanMove);\n    moves = this._moves({\n      legal: true,\n      piece: piece ? piece : pieceType\n    });\n    if (!to) {\n      return null;\n    }\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (!from) {\n        // if there is no from square, it could be just 'x' missing from a capture\n        if (cleanMove === strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n          return moves[i];\n        }\n        // hand-compare move properties with the results from our permissive regex\n      } else if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[from] == moves[i].from && Ox88[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n        return moves[i];\n      } else if (overlyDisambiguated) {\n        /*\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n         */\n        const square = algebraic(moves[i].from);\n        if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n          return moves[i];\n        }\n      }\n    }\n    return null;\n  }\n  ascii() {\n    let s = '   +------------------------+\\n';\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n      if (this._board[i]) {\n        const piece = this._board[i].type;\n        const color = this._board[i].color;\n        const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      } else {\n        s += ' . ';\n      }\n      if (i + 1 & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h';\n    return s;\n  }\n  perft(depth) {\n    const moves = this._moves({\n      legal: false\n    });\n    let nodes = 0;\n    const color = this._turn;\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1);\n        } else {\n          nodes++;\n        }\n      }\n      this._undoMove();\n    }\n    return nodes;\n  }\n  turn() {\n    return this._turn;\n  }\n  board() {\n    const output = [];\n    let row = [];\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null);\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color\n        });\n      }\n      if (i + 1 & 0x88) {\n        output.push(row);\n        row = [];\n        i += 8;\n      }\n    }\n    return output;\n  }\n  squareColor(square) {\n    if (square in Ox88) {\n      const sq = Ox88[square];\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n    }\n    return null;\n  }\n  history() {\n    let {\n      verbose = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const reversedHistory = [];\n    const moveHistory = [];\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    while (true) {\n      const move = reversedHistory.pop();\n      if (!move) {\n        break;\n      }\n      if (verbose) {\n        moveHistory.push(new Move(this, move));\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()));\n      }\n      this._makeMove(move);\n    }\n    return moveHistory;\n  }\n  /*\n   * Keeps track of position occurrence counts for the purpose of repetition\n   * checking. Old positions are removed from the map if their counts are reduced to 0.\n   */\n  _getPositionCount(hash) {\n    var _this$_positionCount$;\n    return (_this$_positionCount$ = this._positionCount.get(hash)) !== null && _this$_positionCount$ !== void 0 ? _this$_positionCount$ : 0;\n  }\n  _incPositionCount() {\n    var _this$_positionCount$2;\n    this._positionCount.set(this._hash, ((_this$_positionCount$2 = this._positionCount.get(this._hash)) !== null && _this$_positionCount$2 !== void 0 ? _this$_positionCount$2 : 0) + 1);\n  }\n  _decPositionCount(hash) {\n    var _this$_positionCount$3;\n    const currentCount = (_this$_positionCount$3 = this._positionCount.get(hash)) !== null && _this$_positionCount$3 !== void 0 ? _this$_positionCount$3 : 0;\n    if (currentCount === 1) {\n      this._positionCount.delete(hash);\n    } else {\n      this._positionCount.set(hash, currentCount - 1);\n    }\n  }\n  _pruneComments() {\n    const reversedHistory = [];\n    const currentComments = {};\n    const copyComment = fen => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen];\n      }\n    };\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n    copyComment(this.fen());\n    while (true) {\n      const move = reversedHistory.pop();\n      if (!move) {\n        break;\n      }\n      this._makeMove(move);\n      copyComment(this.fen());\n    }\n    this._comments = currentComments;\n  }\n  getComment() {\n    return this._comments[this.fen()];\n  }\n  setComment(comment) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n  }\n  /**\n   * @deprecated Renamed to `removeComment` for consistency\n   */\n  deleteComment() {\n    return this.removeComment();\n  }\n  removeComment() {\n    const comment = this._comments[this.fen()];\n    delete this._comments[this.fen()];\n    return comment;\n  }\n  getComments() {\n    this._pruneComments();\n    return Object.keys(this._comments).map(fen => {\n      return {\n        fen: fen,\n        comment: this._comments[fen]\n      };\n    });\n  }\n  /**\n   * @deprecated Renamed to `removeComments` for consistency\n   */\n  deleteComments() {\n    return this.removeComments();\n  }\n  removeComments() {\n    this._pruneComments();\n    return Object.keys(this._comments).map(fen => {\n      const comment = this._comments[fen];\n      delete this._comments[fen];\n      return {\n        fen: fen,\n        comment: comment\n      };\n    });\n  }\n  setCastlingRights(color, rights) {\n    for (const side of [KING, QUEEN]) {\n      if (rights[side] !== undefined) {\n        if (rights[side]) {\n          this._castling[color] |= SIDES[side];\n        } else {\n          this._castling[color] &= ~SIDES[side];\n        }\n      }\n    }\n    this._updateCastlingRights();\n    const result = this.getCastlingRights(color);\n    return (rights[KING] === undefined || rights[KING] === result[KING]) && (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]);\n  }\n  getCastlingRights(color) {\n    return {\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0\n    };\n  }\n  moveNumber() {\n    return this._moveNumber;\n  }\n}","map":{"version":3,"names":["parse","MASK64","rotl","x","k","wrappingMul","y","xoroshiro128","state","s0","BigInt","s1","result","rand","PIECE_KEYS","Array","from","length","EP_KEYS","CASTLING_KEYS","SIDE_KEY","WHITE","BLACK","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","DEFAULT_POSITION","Move","constructor","chess","internal","_defineProperty","color","piece","to","flags","captured","promotion","fromAlgebraic","algebraic","toAlgebraic","san","legal","lan","before","fen","after","flag","BITS","FLAGS","isCapture","indexOf","isPromotion","isEnPassant","isKingsideCastle","isQueensideCastle","isBigPawn","EMPTY","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","SQUARES","SEVEN_TAG_ROSTER","Event","Site","Date","Round","White","Black","Result","SUPLEMENTAL_TAGS","WhiteTitle","BlackTitle","WhiteElo","BlackElo","WhiteUSCF","BlackUSCF","WhiteNA","BlackNA","WhiteType","BlackType","EventDate","EventSponsor","Section","Stage","Board","Opening","Variation","SubVariation","ECO","NIC","Time","UTCTime","UTCDate","TimeControl","SetUp","FEN","Termination","Annotator","Mode","PlyCount","HEADER_TEMPLATE","_objectSpread","Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","ATTACKS","RAYS","PIECE_MASKS","p","SYMBOLS","PROMOTIONS","RANK_1","RANK_2","RANK_7","RANK_8","SIDES","ROOKS","square","SECOND_RANK","rank","file","isDigit","c","f","substring","swapColor","validateFen","tokens","split","ok","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","i","sumFields","previousWasNumber","kings","regex","concat","match","some","char","toUpperCase","getDisambiguator","move","moves","ambiguities","sameRank","sameFile","len","ambigFrom","ambigTo","ambigPiece","charAt","addMove","arguments","undefined","push","inferPieceType","pieceType","matches","toLowerCase","strippedSan","replace","Chess","skipValidation","Map","load","clear","preserveHeaders","_board","_kings","_turn","_castling","_epSquare","_halfMoves","_moveNumber","_history","_comments","_header","_hash","_computeHash","_positionCount","adjustments","slice","join","Error","position","_put","type","_updateSetup","_incPositionCount","forceEnpassantSquare","empty","castling","epSquare","bigPawnSquare","squares","_this$_board$square","_this$_board$square2","_makeMove","isLegal","_isKingAttacked","_undoMove","_pieceKey","colorIndex","typeIndex","_epKey","_castlingKey","index","hash","reset","get","findPiece","_this$_board$i","put","_ref","_updateCastlingRights","_updateEnPassantSquare","_set","sq","_ref2","currentPieceOnSquare","_clear","remove","_this$_board$Ox88$e","_this$_board$Ox88$e2","_this$_board$Ox88$e3","_this$_board$Ox88$e4","_this$_board$Ox88$a","_this$_board$Ox88$a2","_this$_board$Ox88$h","_this$_board$Ox88$h2","_this$_board$Ox88$a3","_this$_board$Ox88$a4","_this$_board$Ox88$h3","_this$_board$Ox88$h4","whiteKingInPlace","blackKingInPlace","_this$_board$currentS","_this$_board$currentS2","startSquare","currentSquare","attackers","canCapture","_this$_board$square3","_this$_board$square4","_attacked","verbose","difference","offset","j","blocked","attackedBy","toString","isAttacked","isCheck","inCheck","isCheckmate","_moves","isStalemate","isInsufficientMaterial","pieces","bishops","numPieces","squareColor","sum","isThreefoldRepetition","_getPositionCount","isDrawByFiftyMoves","isDraw","isGameOver","map","_moveToSan","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","_this$_board$to","castlingFrom","castlingTo","legalMoves","strict","moveObj","_moveFromSan","JSON","stringify","prettyMove","_push","turn","_movePiece","_this$_board","_this$_board2","_this$_board3","_this$_board4","undo","_decPositionCount","old","pop","pgn","newline","maxWidth","headerExists","headerTag","appendComment","moveString","comment","delimiter","reversedHistory","prefix","strip","wrapComment","width","token","currentWidth","includes","header","_len","args","_key","setHeader","key","value","_ref3","getHeaders","removeHeader","nonNullHeaders","Object","entries","loadPgn","newlineChar","RegExp","parsedPgn","headers","node","root","variations","keys","output","disambiguator","cleanMove","overlyDisambiguated","ascii","s","symbol","perft","depth","nodes","board","row","history","moveHistory","_this$_positionCount$","_this$_positionCount$2","set","_this$_positionCount$3","currentCount","delete","_pruneComments","currentComments","copyComment","getComment","setComment","deleteComment","removeComment","getComments","deleteComments","removeComments","setCastlingRights","rights","side","getCastlingRights"],"sources":["C:\\Users\\krishan kant\\Desktop\\Js\\game\\frontend\\node_modules\\chess.js\\src\\chess.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport { parse } from './pgn'\n\nconst MASK64 = 0xffffffffffffffffn\n\nfunction rotl(x: bigint, k: bigint): bigint {\n  return ((x << k) | (x >> (64n - k))) & 0xffffffffffffffffn\n}\n\nfunction wrappingMul(x: bigint, y: bigint) {\n  return (x * y) & MASK64\n}\n\n// xoroshiro128**\nexport function xoroshiro128(state: bigint) {\n  return function () {\n    let s0 = BigInt(state & MASK64)\n    let s1 = BigInt((state >> 64n) & MASK64)\n\n    const result = wrappingMul(rotl(wrappingMul(s0, 5n), 7n), 9n)\n\n    s1 ^= s0\n    s0 = (rotl(s0, 24n) ^ s1 ^ (s1 << 16n)) & MASK64\n    s1 = rotl(s1, 37n)\n\n    state = (s1 << 64n) | s0\n\n    return result\n  }\n}\n\nconst rand = xoroshiro128(0xa187eb39cdcaed8f31c4b365b102e01en)\n\nconst PIECE_KEYS = Array.from({ length: 2 }, () =>\n  Array.from({ length: 6 }, () => Array.from({ length: 128 }, () => rand())),\n)\n\nconst EP_KEYS = Array.from({ length: 8 }, () => rand())\n\nconst CASTLING_KEYS = Array.from({ length: 16 }, () => rand())\n\nconst SIDE_KEY = rand()\n\nexport const WHITE = 'w'\nexport const BLACK = 'b'\n\nexport const PAWN = 'p'\nexport const KNIGHT = 'n'\nexport const BISHOP = 'b'\nexport const ROOK = 'r'\nexport const QUEEN = 'q'\nexport const KING = 'k'\n\nexport type Color = 'w' | 'b'\nexport type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k'\n\n// prettier-ignore\nexport type Square =\n    'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' |\n    'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' |\n    'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' |\n    'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' |\n    'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' |\n    'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' |\n    'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' |\n    'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1'\n\nexport const DEFAULT_POSITION =\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\nexport type Piece = {\n  color: Color\n  type: PieceSymbol\n}\n\ntype InternalMove = {\n  color: Color\n  from: number\n  to: number\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: number\n}\n\ninterface History {\n  move: InternalMove\n  kings: Record<Color, number>\n  turn: Color\n  castling: Record<Color, number>\n  epSquare: number\n  halfMoves: number\n  moveNumber: number\n}\n\nexport class Move {\n  color: Color\n  from: Square\n  to: Square\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n\n  /**\n   * @deprecated This field is deprecated and will be removed in version 2.0.0.\n   * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n   * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n   * `isBigPawn`\n   */\n  flags: string\n\n  san: string\n  lan: string\n  before: string\n  after: string\n\n  constructor(chess: Chess, internal: InternalMove) {\n    const { color, piece, from, to, flags, captured, promotion } = internal\n\n    const fromAlgebraic = algebraic(from)\n    const toAlgebraic = algebraic(to)\n\n    this.color = color\n    this.piece = piece\n    this.from = fromAlgebraic\n    this.to = toAlgebraic\n\n    /*\n     * HACK: The chess['_method']() calls below invoke private methods in the\n     * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n     * code cleaner elsewhere.\n     */\n\n    this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }))\n    this.lan = fromAlgebraic + toAlgebraic\n    this.before = chess.fen()\n\n    // Generate the FEN for the 'after' key\n    chess['_makeMove'](internal)\n    this.after = chess.fen()\n    chess['_undoMove']()\n\n    // Build the text representation of the move flags\n    this.flags = ''\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        this.flags += FLAGS[flag]\n      }\n    }\n\n    if (captured) {\n      this.captured = captured\n    }\n\n    if (promotion) {\n      this.promotion = promotion\n      this.lan += promotion\n    }\n  }\n\n  isCapture() {\n    return this.flags.indexOf(FLAGS['CAPTURE']) > -1\n  }\n\n  isPromotion() {\n    return this.flags.indexOf(FLAGS['PROMOTION']) > -1\n  }\n\n  isEnPassant() {\n    return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1\n  }\n\n  isKingsideCastle() {\n    return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1\n  }\n\n  isQueensideCastle() {\n    return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1\n  }\n\n  isBigPawn() {\n    return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1\n  }\n}\n\nconst EMPTY = -1\n\nconst FLAGS: Record<string, string> = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q',\n}\n\n// prettier-ignore\nexport const SQUARES: Square[] = [\n  'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n  'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n  'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n  'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n  'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n  'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n  'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n  'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n]\n\nconst BITS: Record<string, number> = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64,\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n// these are required, according to spec\nexport const SEVEN_TAG_ROSTER: Record<string, string> = {\n  Event: '?',\n  Site: '?',\n  Date: '????.??.??',\n  Round: '?',\n  White: '?',\n  Black: '?',\n  Result: '*',\n}\n\n/**\n * These nulls are placeholders to fix the order of tags (as they appear in PGN spec); null values will be\n * eliminated in getHeaders()\n */\nconst SUPLEMENTAL_TAGS: Record<string, string | null> = {\n  WhiteTitle: null,\n  BlackTitle: null,\n  WhiteElo: null,\n  BlackElo: null,\n  WhiteUSCF: null,\n  BlackUSCF: null,\n  WhiteNA: null,\n  BlackNA: null,\n  WhiteType: null,\n  BlackType: null,\n  EventDate: null,\n  EventSponsor: null,\n  Section: null,\n  Stage: null,\n  Board: null,\n  Opening: null,\n  Variation: null,\n  SubVariation: null,\n  ECO: null,\n  NIC: null,\n  Time: null,\n  UTCTime: null,\n  UTCDate: null,\n  TimeControl: null,\n  SetUp: null,\n  FEN: null,\n  Termination: null,\n  Annotator: null,\n  Mode: null,\n  PlyCount: null,\n}\n\nconst HEADER_TEMPLATE = {\n  ...SEVEN_TAG_ROSTER,\n  ...SUPLEMENTAL_TAGS,\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88: Record<Square, number> = {\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n}\n\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15],\n}\n\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\n}\n\n// prettier-ignore\nconst ATTACKS = [\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n];\n\n// prettier-ignore\nconst RAYS = [\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n];\n\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 }\n\nconst SYMBOLS = 'pnbrqkPNBRQK'\n\nconst PROMOTIONS: PieceSymbol[] = [KNIGHT, BISHOP, ROOK, QUEEN]\n\nconst RANK_1 = 7\nconst RANK_2 = 6\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1\nconst RANK_8 = 0\n\nconst SIDES = {\n  [KING]: BITS.KSIDE_CASTLE,\n  [QUEEN]: BITS.QSIDE_CASTLE,\n}\n\nconst ROOKS = {\n  w: [\n    { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n  ],\n  b: [\n    { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n  ],\n}\n\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 }\n\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square: number): number {\n  return square >> 4\n}\n\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square: number): number {\n  return square & 0xf\n}\n\nfunction isDigit(c: string): boolean {\n  return '0123456789'.indexOf(c) !== -1\n}\n\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square: number): Square {\n  const f = file(square)\n  const r = rank(square)\n  return ('abcdefgh'.substring(f, f + 1) +\n    '87654321'.substring(r, r + 1)) as Square\n}\n\nfunction swapColor(color: Color): Color {\n  return color === WHITE ? BLACK : WHITE\n}\n\nexport function validateFen(fen: string): { ok: boolean; error?: string } {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/)\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields',\n    }\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10)\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer',\n    }\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10)\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error:\n        'Invalid FEN: half move counter number must be a non-negative integer',\n    }\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/')\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n    }\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0\n    let previousWasNumber = false\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\n          }\n        }\n        sumFields += parseInt(rows[i][k], 10)\n        previousWasNumber = true\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\n          }\n        }\n        sumFields += 1\n        previousWasNumber = false\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n      }\n    }\n  }\n\n  // 9th criterion: is en-passant square legal?\n  if (\n    (tokens[3][1] == '3' && tokens[1] == 'w') ||\n    (tokens[3][1] == '6' && tokens[1] == 'b')\n  ) {\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\n  }\n\n  // 10th criterion: does chess position contain exact two kings?\n  const kings = [\n    { color: 'white', regex: /K/g },\n    { color: 'black', regex: /k/g },\n  ]\n\n  for (const { color, regex } of kings) {\n    if (!regex.test(tokens[0])) {\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\n    }\n\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\n    }\n  }\n\n  // 11th criterion: are any pawns on the first or eighth rows?\n  if (\n    Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')\n  ) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: some pawns are on the edge rows',\n    }\n  }\n\n  return { ok: true }\n}\n\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move: InternalMove, moves: InternalMove[]): string {\n  const from = move.from\n  const to = move.to\n  const piece = move.piece\n\n  let ambiguities = 0\n  let sameRank = 0\n  let sameFile = 0\n\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from\n    const ambigTo = moves[i].to\n    const ambigPiece = moves[i].piece\n\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++\n\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++\n      }\n\n      if (file(from) === file(ambigFrom)) {\n        sameFile++\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from)\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1)\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0)\n    }\n  }\n\n  return ''\n}\n\nfunction addMove(\n  moves: InternalMove[],\n  color: Color,\n  from: number,\n  to: number,\n  piece: PieceSymbol,\n  captured: PieceSymbol | undefined = undefined,\n  flags: number = BITS.NORMAL,\n) {\n  const r = rank(to)\n\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i]\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION,\n      })\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags,\n    })\n  }\n}\n\nfunction inferPieceType(san: string): PieceSymbol | undefined {\n  let pieceType = san.charAt(0)\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n    if (matches) {\n      return undefined\n    }\n    return PAWN\n  }\n  pieceType = pieceType.toLowerCase()\n  if (pieceType === 'o') {\n    return KING\n  }\n  return pieceType as PieceSymbol\n}\n\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move: string): string {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n}\n\nexport class Chess {\n  private _board = new Array<Piece>(128)\n  private _turn: Color = WHITE\n  private _header: Record<string, string | null> = {}\n  private _kings: Record<Color, number> = { w: EMPTY, b: EMPTY }\n  private _epSquare = -1\n  private _halfMoves = 0\n  private _moveNumber = 0\n  private _history: History[] = []\n  private _comments: Record<string, string> = {}\n  private _castling: Record<Color, number> = { w: 0, b: 0 }\n\n  private _hash = 0n\n\n  // tracks number of times a position has been seen for repetition checking\n  private _positionCount = new Map<bigint, number>()\n\n  constructor(fen = DEFAULT_POSITION, { skipValidation = false } = {}) {\n    this.load(fen, { skipValidation })\n  }\n\n  clear({ preserveHeaders = false } = {}) {\n    this._board = new Array<Piece>(128)\n    this._kings = { w: EMPTY, b: EMPTY }\n    this._turn = WHITE\n    this._castling = { w: 0, b: 0 }\n    this._epSquare = EMPTY\n    this._halfMoves = 0\n    this._moveNumber = 1\n    this._history = []\n    this._comments = {}\n    this._header = preserveHeaders ? this._header : { ...HEADER_TEMPLATE }\n    this._hash = this._computeHash()\n    this._positionCount = new Map<bigint, number>()\n\n    /*\n     * Delete the SetUp and FEN headers (if preserved), the board is empty and\n     * these headers don't make sense in this state. They'll get added later\n     * via .load() or .put()\n     */\n    this._header['SetUp'] = null\n    this._header['FEN'] = null\n  }\n\n  load(fen: string, { skipValidation = false, preserveHeaders = false } = {}) {\n    let tokens = fen.split(/\\s+/)\n\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1']\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ')\n    }\n\n    tokens = fen.split(/\\s+/)\n\n    if (!skipValidation) {\n      const { ok, error } = validateFen(fen)\n      if (!ok) {\n        throw new Error(error)\n      }\n    }\n\n    const position = tokens[0]\n    let square = 0\n\n    this.clear({ preserveHeaders })\n\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        const color = piece < 'a' ? WHITE : BLACK\n        this._put(\n          { type: piece.toLowerCase() as PieceSymbol, color },\n          algebraic(square),\n        )\n        square++\n      }\n    }\n\n    this._turn = tokens[1] as Color\n\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3] as Square]\n    this._halfMoves = parseInt(tokens[4], 10)\n    this._moveNumber = parseInt(tokens[5], 10)\n\n    this._hash = this._computeHash()\n    this._updateSetup(fen)\n    this._incPositionCount()\n  }\n\n  fen({\n    forceEnpassantSquare = false,\n  }: { forceEnpassantSquare?: boolean } = {}) {\n    let empty = 0\n    let fen = ''\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        const { color, type: piece } = this._board[i]\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      } else {\n        empty++\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== Ox88.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    let castling = ''\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K'\n    }\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q'\n    }\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k'\n    }\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q'\n    }\n\n    // do we have an empty castling flag?\n    castling = castling || '-'\n\n    let epSquare = '-'\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n    if (this._epSquare !== EMPTY) {\n      if (forceEnpassantSquare) {\n        epSquare = algebraic(this._epSquare)\n      } else {\n        const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n        const squares = [bigPawnSquare + 1, bigPawnSquare - 1]\n\n        for (const square of squares) {\n          // is the square off the board?\n          if (square & 0x88) {\n            continue\n          }\n\n          const color = this._turn\n\n          // is there a pawn that can capture the epSquare?\n          if (\n            this._board[square]?.color === color &&\n            this._board[square]?.type === PAWN\n          ) {\n            // if the pawn makes an ep capture, does it leave its king in check?\n            this._makeMove({\n              color,\n              from: square,\n              to: this._epSquare,\n              piece: PAWN,\n              captured: PAWN,\n              flags: BITS.EP_CAPTURE,\n            })\n            const isLegal = !this._isKingAttacked(color)\n            this._undoMove()\n\n            // if ep is legal, break and set the ep square in the FEN output\n            if (isLegal) {\n              epSquare = algebraic(this._epSquare)\n              break\n            }\n          }\n        }\n      }\n    }\n\n    return [\n      fen,\n      this._turn,\n      castling,\n      epSquare,\n      this._halfMoves,\n      this._moveNumber,\n    ].join(' ')\n  }\n\n  private _pieceKey(i: number) {\n    if (!this._board[i]) {\n      return 0n\n    }\n\n    const { color, type } = this._board[i]\n\n    const colorIndex = {\n      w: 0,\n      b: 1,\n    }[color]\n\n    const typeIndex = {\n      p: 0,\n      n: 1,\n      b: 2,\n      r: 3,\n      q: 4,\n      k: 5,\n    }[type]\n\n    return PIECE_KEYS[colorIndex][typeIndex][i]\n  }\n\n  private _epKey() {\n    return this._epSquare === EMPTY ? 0n : EP_KEYS[this._epSquare & 7]\n  }\n\n  private _castlingKey() {\n    const index = (this._castling.w >> 5) | (this._castling.b >> 3)\n    return CASTLING_KEYS[index]\n  }\n\n  private _computeHash() {\n    let hash = 0n\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      if (this._board[i]) {\n        hash ^= this._pieceKey(i)\n      }\n    }\n\n    hash ^= this._epKey()\n    hash ^= this._castlingKey()\n\n    if (this._turn === 'b') {\n      hash ^= SIDE_KEY\n    }\n\n    return hash\n  }\n\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n  private _updateSetup(fen: string) {\n    if (this._history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      this._header['SetUp'] = '1'\n      this._header['FEN'] = fen\n    } else {\n      this._header['SetUp'] = null\n      this._header['FEN'] = null\n    }\n  }\n\n  reset() {\n    this.load(DEFAULT_POSITION)\n  }\n\n  get(square: Square): Piece | undefined {\n    return this._board[Ox88[square]]\n  }\n\n  findPiece(piece: Piece): Square[] {\n    const squares: Square[] = []\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      // if empty square or wrong color\n      if (!this._board[i] || this._board[i]?.color !== piece.color) {\n        continue\n      }\n\n      // check if square contains the requested piece\n      if (\n        this._board[i].color === piece.color &&\n        this._board[i].type === piece.type\n      ) {\n        squares.push(algebraic(i))\n      }\n    }\n\n    return squares\n  }\n\n  put(\n    { type, color }: { type: PieceSymbol; color: Color },\n    square: Square,\n  ): boolean {\n    if (this._put({ type, color }, square)) {\n      this._updateCastlingRights()\n      this._updateEnPassantSquare()\n      this._updateSetup(this.fen())\n      return true\n    }\n    return false\n  }\n\n  private _set(sq: number, piece: Piece) {\n    this._hash ^= this._pieceKey(sq)\n    this._board[sq] = piece\n    this._hash ^= this._pieceKey(sq)\n  }\n\n  private _put(\n    { type, color }: { type: PieceSymbol; color: Color },\n    square: Square,\n  ): boolean {\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false\n    }\n\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false\n    }\n\n    const sq = Ox88[square]\n\n    // don't let the user place more than one king\n    if (\n      type == KING &&\n      !(this._kings[color] == EMPTY || this._kings[color] == sq)\n    ) {\n      return false\n    }\n\n    const currentPieceOnSquare = this._board[sq]\n\n    // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n    if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n      this._kings[currentPieceOnSquare.color] = EMPTY\n    }\n\n    this._set(sq, { type: type as PieceSymbol, color: color as Color })\n\n    if (type === KING) {\n      this._kings[color] = sq\n    }\n\n    return true\n  }\n\n  private _clear(sq: number) {\n    this._hash ^= this._pieceKey(sq)\n    delete this._board[sq]\n  }\n\n  remove(square: Square): Piece | undefined {\n    const piece = this.get(square)\n    this._clear(Ox88[square])\n    if (piece && piece.type === KING) {\n      this._kings[piece.color] = EMPTY\n    }\n\n    this._updateCastlingRights()\n    this._updateEnPassantSquare()\n    this._updateSetup(this.fen())\n\n    return piece\n  }\n\n  private _updateCastlingRights() {\n    this._hash ^= this._castlingKey()\n\n    const whiteKingInPlace =\n      this._board[Ox88.e1]?.type === KING &&\n      this._board[Ox88.e1]?.color === WHITE\n    const blackKingInPlace =\n      this._board[Ox88.e8]?.type === KING &&\n      this._board[Ox88.e8]?.color === BLACK\n\n    if (\n      !whiteKingInPlace ||\n      this._board[Ox88.a1]?.type !== ROOK ||\n      this._board[Ox88.a1]?.color !== WHITE\n    ) {\n      this._castling.w &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (\n      !whiteKingInPlace ||\n      this._board[Ox88.h1]?.type !== ROOK ||\n      this._board[Ox88.h1]?.color !== WHITE\n    ) {\n      this._castling.w &= ~BITS.KSIDE_CASTLE\n    }\n\n    if (\n      !blackKingInPlace ||\n      this._board[Ox88.a8]?.type !== ROOK ||\n      this._board[Ox88.a8]?.color !== BLACK\n    ) {\n      this._castling.b &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (\n      !blackKingInPlace ||\n      this._board[Ox88.h8]?.type !== ROOK ||\n      this._board[Ox88.h8]?.color !== BLACK\n    ) {\n      this._castling.b &= ~BITS.KSIDE_CASTLE\n    }\n\n    this._hash ^= this._castlingKey()\n  }\n\n  private _updateEnPassantSquare() {\n    if (this._epSquare === EMPTY) {\n      return\n    }\n\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16)\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n    const attackers = [currentSquare + 1, currentSquare - 1]\n\n    if (\n      this._board[startSquare] !== null ||\n      this._board[this._epSquare] !== null ||\n      this._board[currentSquare]?.color !== swapColor(this._turn) ||\n      this._board[currentSquare]?.type !== PAWN\n    ) {\n      this._hash ^= this._epKey()\n      this._epSquare = EMPTY\n      return\n    }\n\n    const canCapture = (square: number) =>\n      !(square & 0x88) &&\n      this._board[square]?.color === this._turn &&\n      this._board[square]?.type === PAWN\n\n    if (!attackers.some(canCapture)) {\n      this._hash ^= this._epKey()\n      this._epSquare = EMPTY\n    }\n  }\n\n  private _attacked(color: Color, square: number): boolean\n  private _attacked(color: Color, square: number, verbose: false): boolean\n  private _attacked(color: Color, square: number, verbose: true): Square[]\n  private _attacked(color: Color, square: number, verbose?: boolean) {\n    const attackers: Square[] = []\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue\n      }\n\n      const piece = this._board[i]\n      const difference = i - square\n\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue\n      }\n\n      const index = difference + 119\n\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (\n            (difference > 0 && piece.color === WHITE) ||\n            (difference <= 0 && piece.color === BLACK)\n          ) {\n            if (!verbose) {\n              return true\n            } else {\n              attackers.push(algebraic(i))\n            }\n          }\n          continue\n        }\n\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') {\n          if (!verbose) {\n            return true\n          } else {\n            attackers.push(algebraic(i))\n            continue\n          }\n        }\n\n        const offset = RAYS[index]\n        let j = i + offset\n\n        let blocked = false\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) {\n          if (!verbose) {\n            return true\n          } else {\n            attackers.push(algebraic(i))\n            continue\n          }\n        }\n      }\n    }\n\n    if (verbose) {\n      return attackers\n    } else {\n      return false\n    }\n  }\n\n  attackers(square: Square, attackedBy?: Color): Square[] {\n    if (!attackedBy) {\n      return this._attacked(this._turn, Ox88[square], true)\n    } else {\n      return this._attacked(attackedBy, Ox88[square], true)\n    }\n  }\n\n  private _isKingAttacked(color: Color): boolean {\n    const square = this._kings[color]\n    return square === -1 ? false : this._attacked(swapColor(color), square)\n  }\n\n  hash(): string {\n    return this._hash.toString(16)\n  }\n\n  isAttacked(square: Square, attackedBy: Color): boolean {\n    return this._attacked(attackedBy, Ox88[square])\n  }\n\n  isCheck(): boolean {\n    return this._isKingAttacked(this._turn)\n  }\n\n  inCheck(): boolean {\n    return this.isCheck()\n  }\n\n  isCheckmate(): boolean {\n    return this.isCheck() && this._moves().length === 0\n  }\n\n  isStalemate(): boolean {\n    return !this.isCheck() && this._moves().length === 0\n  }\n\n  isInsufficientMaterial(): boolean {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces: Record<PieceSymbol, number> = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0,\n    }\n    const bishops = []\n    let numPieces = 0\n    let squareColor = 0\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      const piece = this._board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(squareColor)\n        }\n        numPieces++\n      }\n    }\n\n    // k vs. k\n    if (numPieces === 2) {\n      return true\n    } else if (\n      // k vs. kn .... or .... k vs. kb\n      numPieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (numPieces === pieces[BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0\n      const len = bishops.length\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  isThreefoldRepetition(): boolean {\n    return this._getPositionCount(this._hash) >= 3\n  }\n\n  isDrawByFiftyMoves(): boolean {\n    return this._halfMoves >= 100 // 50 moves per side = 100 half moves\n  }\n\n  isDraw(): boolean {\n    return (\n      this.isDrawByFiftyMoves() ||\n      this.isStalemate() ||\n      this.isInsufficientMaterial() ||\n      this.isThreefoldRepetition()\n    )\n  }\n\n  isGameOver(): boolean {\n    return this.isCheckmate() || this.isDraw()\n  }\n\n  moves(): string[]\n  moves({ square }: { square: Square }): string[]\n  moves({ piece }: { piece: PieceSymbol }): string[]\n\n  moves({ square, piece }: { square: Square; piece: PieceSymbol }): string[]\n\n  moves({ verbose, square }: { verbose: true; square?: Square }): Move[]\n  moves({ verbose, square }: { verbose: false; square?: Square }): string[]\n  moves({\n    verbose,\n    square,\n  }: {\n    verbose?: boolean\n    square?: Square\n  }): string[] | Move[]\n\n  moves({ verbose, piece }: { verbose: true; piece?: PieceSymbol }): Move[]\n  moves({ verbose, piece }: { verbose: false; piece?: PieceSymbol }): string[]\n  moves({\n    verbose,\n    piece,\n  }: {\n    verbose?: boolean\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: true\n    square?: Square\n    piece?: PieceSymbol\n  }): Move[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: false\n    square?: Square\n    piece?: PieceSymbol\n  }): string[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose?: boolean\n    square?: Square\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({ square, piece }: { square?: Square; piece?: PieceSymbol }): Move[]\n\n  moves({\n    verbose = false,\n    square = undefined,\n    piece = undefined,\n  }: { verbose?: boolean; square?: Square; piece?: PieceSymbol } = {}) {\n    const moves = this._moves({ square, piece })\n\n    if (verbose) {\n      return moves.map((move) => new Move(this, move))\n    } else {\n      return moves.map((move) => this._moveToSan(move, moves))\n    }\n  }\n\n  private _moves({\n    legal = true,\n    piece = undefined,\n    square = undefined,\n  }: {\n    legal?: boolean\n    piece?: PieceSymbol\n    square?: Square\n  } = {}): InternalMove[] {\n    const forSquare = square ? (square.toLowerCase() as Square) : undefined\n    const forPiece = piece?.toLowerCase()\n\n    const moves: InternalMove[] = []\n    const us = this._turn\n    const them = swapColor(us)\n\n    let firstSquare = Ox88.a8\n    let lastSquare = Ox88.h1\n    let singleSquare = false\n\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return []\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare]\n        singleSquare = true\n      }\n    }\n\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7\n        continue\n      }\n\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue\n      }\n      const { type } = this._board[from]\n\n      let to: number\n      if (type === PAWN) {\n        if (forPiece && forPiece !== type) continue\n\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0]\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, PAWN)\n\n          // double square\n          to = from + PAWN_OFFSETS[us][1]\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN)\n          }\n        }\n\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j]\n          if (to & 0x88) continue\n\n          if (this._board[to]?.color === them) {\n            addMove(\n              moves,\n              us,\n              from,\n              to,\n              PAWN,\n              this._board[to].type,\n              BITS.CAPTURE,\n            )\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE)\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue\n\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j]\n          to = from\n\n          while (true) {\n            to += offset\n            if (to & 0x88) break\n\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type)\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break\n\n              addMove(\n                moves,\n                us,\n                from,\n                to,\n                type,\n                this._board[to].type,\n                BITS.CAPTURE,\n              )\n              break\n            }\n\n            /* break, if knight or king */\n            if (type === KNIGHT || type === KING) break\n          }\n        }\n      }\n    }\n\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n\n    if (forPiece === undefined || forPiece === KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom + 2\n\n          if (\n            !this._board[castlingFrom + 1] &&\n            !this._board[castlingTo] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom + 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.KSIDE_CASTLE,\n            )\n          }\n        }\n\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom - 2\n\n          if (\n            !this._board[castlingFrom - 1] &&\n            !this._board[castlingFrom - 2] &&\n            !this._board[castlingFrom - 3] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom - 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.QSIDE_CASTLE,\n            )\n          }\n        }\n      }\n    }\n\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal || this._kings[us] === -1) {\n      return moves\n    }\n\n    // filter out illegal moves\n    const legalMoves = []\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i])\n      }\n      this._undoMove()\n    }\n\n    return legalMoves\n  }\n\n  move(\n    move: string | { from: string; to: string; promotion?: string },\n    { strict = false }: { strict?: boolean } = {},\n  ): Move {\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n\n    let moveObj = null\n\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict)\n    } else if (typeof move === 'object') {\n      const moves = this._moves()\n\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (\n          move.from === algebraic(moves[i].from) &&\n          move.to === algebraic(moves[i].to) &&\n          (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)\n        ) {\n          moveObj = moves[i]\n          break\n        }\n      }\n    }\n\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`)\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`)\n      }\n    }\n\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n    const prettyMove = new Move(this, moveObj)\n\n    this._makeMove(moveObj)\n    this._incPositionCount()\n    return prettyMove\n  }\n\n  private _push(move: InternalMove) {\n    this._history.push({\n      move,\n      kings: { b: this._kings.b, w: this._kings.w },\n      turn: this._turn,\n      castling: { b: this._castling.b, w: this._castling.w },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber,\n    })\n  }\n\n  private _movePiece(from: number, to: number) {\n    this._hash ^= this._pieceKey(from)\n\n    this._board[to] = this._board[from]\n    delete this._board[from]\n\n    this._hash ^= this._pieceKey(to)\n  }\n\n  private _makeMove(move: InternalMove) {\n    const us = this._turn\n    const them = swapColor(us)\n    this._push(move)\n\n    this._hash ^= this._epKey()\n    this._hash ^= this._castlingKey()\n\n    if (move.captured) {\n      this._hash ^= this._pieceKey(move.to)\n    }\n\n    this._movePiece(move.from, move.to)\n\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === BLACK) {\n        this._clear(move.to - 16)\n      } else {\n        this._clear(move.to + 16)\n      }\n    }\n\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._clear(move.to)\n      this._set(move.to, { type: move.promotion, color: us })\n    }\n\n    // if we moved the king\n    if (this._board[move.to].type === KING) {\n      this._kings[us] = move.to\n\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1\n        const castlingFrom = move.to + 1\n        this._movePiece(castlingFrom, castlingTo)\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1\n        const castlingFrom = move.to - 2\n        this._movePiece(castlingFrom, castlingTo)\n      }\n\n      // turn off castling\n      this._castling[us] = 0\n    }\n\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          this._castling[us] & ROOKS[us][i].flag\n        ) {\n          this._castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          this._castling[them] & ROOKS[them][i].flag\n        ) {\n          this._castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    this._hash ^= this._castlingKey()\n\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      let epSquare\n\n      if (us === BLACK) {\n        epSquare = move.to - 16\n      } else {\n        epSquare = move.to + 16\n      }\n\n      if (\n        (!((move.to - 1) & 0x88) &&\n          this._board[move.to - 1]?.type === PAWN &&\n          this._board[move.to - 1]?.color === them) ||\n        (!((move.to + 1) & 0x88) &&\n          this._board[move.to + 1]?.type === PAWN &&\n          this._board[move.to + 1]?.color === them)\n      ) {\n        this._epSquare = epSquare\n        this._hash ^= this._epKey()\n      } else {\n        this._epSquare = EMPTY\n      }\n    } else {\n      this._epSquare = EMPTY\n    }\n\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === PAWN) {\n      this._halfMoves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0\n    } else {\n      this._halfMoves++\n    }\n\n    if (us === BLACK) {\n      this._moveNumber++\n    }\n\n    this._turn = them\n    this._hash ^= SIDE_KEY\n  }\n\n  undo(): Move | null {\n    const hash = this._hash\n    const move = this._undoMove()\n    if (move) {\n      const prettyMove = new Move(this, move)\n      this._decPositionCount(hash)\n      return prettyMove\n    }\n    return null\n  }\n\n  private _undoMove(): InternalMove | null {\n    const old = this._history.pop()\n    if (old === undefined) {\n      return null\n    }\n\n    this._hash ^= this._epKey()\n    this._hash ^= this._castlingKey()\n\n    const move = old.move\n\n    this._kings = old.kings\n    this._turn = old.turn\n    this._castling = old.castling\n    this._epSquare = old.epSquare\n    this._halfMoves = old.halfMoves\n    this._moveNumber = old.moveNumber\n\n    this._hash ^= this._epKey()\n    this._hash ^= this._castlingKey()\n    this._hash ^= SIDE_KEY\n\n    const us = this._turn\n    const them = swapColor(us)\n\n    this._movePiece(move.to, move.from)\n\n    // to undo any promotions\n    if (move.piece) {\n      this._clear(move.from)\n      this._set(move.from, { type: move.piece, color: us })\n    }\n\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index: number\n        if (us === BLACK) {\n          index = move.to - 16\n        } else {\n          index = move.to + 16\n        }\n        this._set(index, { type: PAWN, color: them })\n      } else {\n        // regular capture\n        this._set(move.to, { type: move.captured, color: them })\n      }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo: number, castlingFrom: number\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1\n        castlingFrom = move.to - 1\n      } else {\n        castlingTo = move.to - 2\n        castlingFrom = move.to + 1\n      }\n      this._movePiece(castlingFrom, castlingTo)\n    }\n\n    return move\n  }\n\n  pgn({\n    newline = '\\n',\n    maxWidth = 0,\n  }: { newline?: string; maxWidth?: number } = {}): string {\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n\n    const result: string[] = []\n    let headerExists = false\n\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       *\n       * By using HEADER_TEMPLATE, the order of tags should be preserved; we\n       * do have to check for null placeholders, though, and omit them\n       */\n      const headerTag = this._header[i]\n      if (headerTag) result.push(`[${i} \"${this._header[i]}\"]` + newline)\n      headerExists = true\n    }\n\n    if (headerExists && this._history.length) {\n      result.push(newline)\n    }\n\n    const appendComment = (moveString: string) => {\n      const comment = this._comments[this.fen()]\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : ''\n        moveString = `${moveString}${delimiter}{${comment}}`\n      }\n      return moveString\n    }\n\n    // pop all of history onto reversed_history\n    const reversedHistory = []\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    const moves = []\n    let moveString = ''\n\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''))\n    }\n\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString)\n      const move = reversedHistory.pop()\n\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break\n      }\n\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`\n        // is there a comment preceding the first move?\n        moveString = moveString ? `${moveString} ${prefix}` : prefix\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString)\n        }\n        moveString = this._moveNumber + '.'\n      }\n\n      moveString =\n        moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }))\n      this._makeMove(move)\n    }\n\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString))\n    }\n\n    // is there a result? (there ALWAYS has to be a result according to spec; see Seven Tag Roster)\n    moves.push(this._header.Result || '*')\n\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ')\n    }\n\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop()\n        return true\n      }\n      return false\n    }\n\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width: number, move: string) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--\n          }\n          result.push(newline)\n          width = 0\n        }\n        result.push(token)\n        width += token.length\n        result.push(' ')\n        width++\n      }\n      if (strip()) {\n        width--\n      }\n      return width\n    }\n\n    // wrap the PGN output at max_width\n    let currentWidth = 0\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i])\n          continue\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop()\n        }\n\n        result.push(newline)\n        currentWidth = 0\n      } else if (i !== 0) {\n        result.push(' ')\n        currentWidth++\n      }\n      result.push(moves[i])\n      currentWidth += moves[i].length\n    }\n\n    return result.join('')\n  }\n\n  /**\n   * @deprecated Use `setHeader` and `getHeaders` instead. This method will return null header tags (which is not what you want)\n   */\n  header(...args: string[]): Record<string, string | null> {\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1]\n      }\n    }\n    return this._header\n  }\n\n  // TODO: value validation per spec\n  setHeader(key: string, value: string): Record<string, string> {\n    this._header[key] = value ?? SEVEN_TAG_ROSTER[key] ?? null\n    return this.getHeaders()\n  }\n\n  removeHeader(key: string): boolean {\n    if (key in this._header) {\n      this._header[key] = SEVEN_TAG_ROSTER[key] || null\n      return true\n    }\n    return false\n  }\n\n  // return only non-null headers (omit placemarker nulls)\n  getHeaders(): Record<string, string> {\n    const nonNullHeaders: Record<string, string> = {}\n    for (const [key, value] of Object.entries(this._header)) {\n      if (value !== null) {\n        nonNullHeaders[key] = value\n      }\n    }\n    return nonNullHeaders\n  }\n\n  loadPgn(\n    pgn: string,\n    {\n      strict = false,\n      newlineChar = '\\r?\\n',\n    }: { strict?: boolean; newlineChar?: string } = {},\n  ) {\n    // If newlineChar is not the default, replace all instances with \\n\n    if (newlineChar !== '\\r?\\n') {\n      pgn = pgn.replace(new RegExp(newlineChar, 'g'), '\\n')\n    }\n\n    const parsedPgn = parse(pgn)\n\n    // Put the board in the starting position\n    this.reset()\n\n    // parse PGN header\n    const headers = parsedPgn.headers\n    let fen = ''\n\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key]\n      }\n\n      this.header(key, headers[key])\n    }\n\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, { preserveHeaders: true })\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error(\n            'Invalid PGN: FEN tag must be supplied with SetUp tag',\n          )\n        }\n        // don't clear the headers when loading\n        this.load(headers['FEN'], { preserveHeaders: true })\n      }\n    }\n\n    let node = parsedPgn.root\n\n    while (node) {\n      if (node.move) {\n        const move = this._moveFromSan(node.move, strict)\n\n        if (move == null) {\n          throw new Error(`Invalid move in PGN: ${node.move}`)\n        } else {\n          this._makeMove(move)\n          this._incPositionCount()\n        }\n      }\n\n      if (node.comment !== undefined) {\n        this._comments[this.fen()] = node.comment\n      }\n\n      node = node.variations[0]\n    }\n\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n\n    const result = parsedPgn.result\n    if (\n      result &&\n      Object.keys(this._header).length &&\n      this._header['Result'] !== result\n    ) {\n      this.setHeader('Result', result)\n    }\n  }\n\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n  private _moveToSan(move: InternalMove, moves: InternalMove[]): string {\n    let output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      if (move.piece !== PAWN) {\n        const disambiguator = getDisambiguator(move, moves)\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    this._makeMove(move)\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    this._undoMove()\n\n    return output\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  private _moveFromSan(move: string, strict = false): InternalMove | null {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    let cleanMove = strippedSan(move)\n\n    if (!strict) {\n      if (cleanMove === '0-0') {\n        cleanMove = 'O-O'\n      } else if (cleanMove === '0-0-0') {\n        cleanMove = 'O-O-O'\n      }\n    }\n\n    let pieceType = inferPieceType(cleanMove)\n    let moves = this._moves({ legal: true, piece: pieceType })\n\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i]\n      }\n    }\n\n    // the strict parser failed\n    if (strict) {\n      return null\n    }\n\n    let piece = undefined\n    let matches = undefined\n    let from = undefined\n    let to = undefined\n    let promotion = undefined\n\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n\n    let overlyDisambiguated = false\n\n    matches = cleanMove.match(\n      /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/,\n      //     piece         from              to       promotion\n    )\n\n    if (matches) {\n      piece = matches[1]\n      from = matches[2] as Square\n      to = matches[3] as Square\n      promotion = matches[4]\n\n      if (from.length == 1) {\n        overlyDisambiguated = true\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n\n      matches = cleanMove.match(\n        /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/,\n      )\n\n      if (matches) {\n        piece = matches[1]\n        from = matches[2] as Square\n        to = matches[3] as Square\n        promotion = matches[4]\n\n        if (from.length == 1) {\n          overlyDisambiguated = true\n        }\n      }\n    }\n\n    pieceType = inferPieceType(cleanMove)\n    moves = this._moves({\n      legal: true,\n      piece: piece ? (piece as PieceSymbol) : pieceType,\n    })\n\n    if (!to) {\n      return null\n    }\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (!from) {\n        // if there is no from square, it could be just 'x' missing from a capture\n        if (\n          cleanMove ===\n          strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')\n        ) {\n          return moves[i]\n        }\n        // hand-compare move properties with the results from our permissive regex\n      } else if (\n        (!piece || piece.toLowerCase() == moves[i].piece) &&\n        Ox88[from] == moves[i].from &&\n        Ox88[to] == moves[i].to &&\n        (!promotion || promotion.toLowerCase() == moves[i].promotion)\n      ) {\n        return moves[i]\n      } else if (overlyDisambiguated) {\n        /*\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n         */\n\n        const square = algebraic(moves[i].from)\n        if (\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          Ox88[to] == moves[i].to &&\n          (from == square[0] || from == square[1]) &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  ascii(): string {\n    let s = '   +------------------------+\\n'\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      if (this._board[i]) {\n        const piece = this._board[i].type\n        const color = this._board[i].color\n        const symbol =\n          color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      } else {\n        s += ' . '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h'\n\n    return s\n  }\n\n  perft(depth: number): number {\n    const moves = this._moves({ legal: false })\n    let nodes = 0\n    const color = this._turn\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1)\n        } else {\n          nodes++\n        }\n      }\n      this._undoMove()\n    }\n\n    return nodes\n  }\n\n  turn(): Color {\n    return this._turn\n  }\n\n  board(): ({ square: Square; type: PieceSymbol; color: Color } | null)[][] {\n    const output = []\n    let row = []\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null)\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color,\n        })\n      }\n      if ((i + 1) & 0x88) {\n        output.push(row)\n        row = []\n        i += 8\n      }\n    }\n\n    return output\n  }\n\n  squareColor(square: Square): 'light' | 'dark' | null {\n    if (square in Ox88) {\n      const sq = Ox88[square]\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark'\n    }\n\n    return null\n  }\n\n  history(): string[]\n  history({ verbose }: { verbose: true }): Move[]\n  history({ verbose }: { verbose: false }): string[]\n  history({ verbose }: { verbose: boolean }): string[] | Move[]\n  history({ verbose = false }: { verbose?: boolean } = {}) {\n    const reversedHistory = []\n    const moveHistory = []\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n\n      if (verbose) {\n        moveHistory.push(new Move(this, move))\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()))\n      }\n      this._makeMove(move)\n    }\n\n    return moveHistory\n  }\n\n  /*\n   * Keeps track of position occurrence counts for the purpose of repetition\n   * checking. Old positions are removed from the map if their counts are reduced to 0.\n   */\n  private _getPositionCount(hash: bigint): number {\n    return this._positionCount.get(hash) ?? 0\n  }\n\n  private _incPositionCount() {\n    this._positionCount.set(\n      this._hash,\n      (this._positionCount.get(this._hash) ?? 0) + 1,\n    )\n  }\n\n  private _decPositionCount(hash: bigint) {\n    const currentCount = this._positionCount.get(hash) ?? 0\n\n    if (currentCount === 1) {\n      this._positionCount.delete(hash)\n    } else {\n      this._positionCount.set(hash, currentCount - 1)\n    }\n  }\n\n  private _pruneComments() {\n    const reversedHistory = []\n    const currentComments: Record<string, string> = {}\n\n    const copyComment = (fen: string) => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen]\n      }\n    }\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    copyComment(this.fen())\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n      this._makeMove(move)\n      copyComment(this.fen())\n    }\n    this._comments = currentComments\n  }\n\n  getComment(): string {\n    return this._comments[this.fen()]\n  }\n\n  setComment(comment: string) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']')\n  }\n\n  /**\n   * @deprecated Renamed to `removeComment` for consistency\n   */\n  deleteComment(): string {\n    return this.removeComment()\n  }\n\n  removeComment(): string {\n    const comment = this._comments[this.fen()]\n    delete this._comments[this.fen()]\n    return comment\n  }\n\n  getComments(): { fen: string; comment: string }[] {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen: string) => {\n      return { fen: fen, comment: this._comments[fen] }\n    })\n  }\n\n  /**\n   * @deprecated Renamed to `removeComments` for consistency\n   */\n  deleteComments(): { fen: string; comment: string }[] {\n    return this.removeComments()\n  }\n\n  removeComments(): { fen: string; comment: string }[] {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen) => {\n      const comment = this._comments[fen]\n      delete this._comments[fen]\n      return { fen: fen, comment: comment }\n    })\n  }\n\n  setCastlingRights(\n    color: Color,\n    rights: Partial<Record<typeof KING | typeof QUEEN, boolean>>,\n  ): boolean {\n    for (const side of [KING, QUEEN] as const) {\n      if (rights[side] !== undefined) {\n        if (rights[side]) {\n          this._castling[color] |= SIDES[side]\n        } else {\n          this._castling[color] &= ~SIDES[side]\n        }\n      }\n    }\n\n    this._updateCastlingRights()\n    const result = this.getCastlingRights(color)\n\n    return (\n      (rights[KING] === undefined || rights[KING] === result[KING]) &&\n      (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN])\n    )\n  }\n\n  getCastlingRights(color: Color): { [KING]: boolean; [QUEEN]: boolean } {\n    return {\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n    }\n  }\n\n  moveNumber(): number {\n    return this._moveNumber\n  }\n}\n"],"mappings":"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CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAG,CAAC,EAAE,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,CAC/C;AAED;AACA,MAAMC,IAAI,GAAG,CACV,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAE,CAAC,EAC5D,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAG,CAAC,CAAC,EAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAC,CAAC,EAAE,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}